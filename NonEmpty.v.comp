Require Import Coq.Classes.RelationClasses.
Require Export Coq.Logic.ProofIrrelevance.
Require Import Coq.Program.Wf.
Require Import Coq.Relations.Relations.
Require Import Coq.Sorting.Sorted.

Require Export Ssreflect.ssreflect.
Require Export Ssreflect.ssrfun.
Require Export Ssreflect.ssrbool.
Require Export Ssreflect.eqtype.
Require Export Ssreflect.seq.
Require Export Ssreflect.ssrnat.

Generalizable All Variables.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

(** ** NonEmpty lists *)

Section NonEmptySub.

Variable a : Type.

Inductive NonEmpty : predArgType := NE s of 0 < @size a s.

Coercion list_of_ne i := let: NE s _ := i in s.

Canonical NonEmpty_subType := [subType for list_of_ne].
(* Definition NonEmpty_eqMixin := Eval hnf in [eqMixin of NonEmpty by <:]. *)
(* Canonical NonEmpty_eqType := Eval hnf in EqType NonEmpty NonEmpty_eqMixin. *)
(* Definition NonEmpty_choiceMixin := [choiceMixin of NonEmpty by <:]. *)
(* Canonical NonEmpty_choiceType := *)
(*   Eval hnf in ChoiceType NonEmpty NonEmpty_choiceMixin. *)
(* Definition NonEmpty_countMixin := [countMixin of NonEmpty by <:]. *)
(* Canonical NonEmpty_countType := Eval hnf in CountType NonEmpty NonEmpty_countMixin. *)
(* Canonical NonEmpty_subCountType := [subCountType of NonEmpty]. *)

Definition ne_pred_sort (pT : predType NonEmpty) := pred_sort pT.
Identity Coercion pred_sort_of_ne : ne_pred_sort >-> pred_sort.

Definition NE_ev (ne : NonEmpty) : size ne > 0 :=
  let: NE _ ev := ne in ev.

Notation "[ ::: x1 ]" := (@NE [:: x1] (ltn0Sn 0))
  (at level 0, format "[ :::  x1 ]") : seq_scope.

Notation "[ ::: x & s ]" := (@NE (x :: s) (ltn0Sn (size s)))
  (at level 0, only parsing) : seq_scope.

(*
Notation "[ ::: x1 , x2 , .. , xn & s ]" := (x1 :: x2 :: .. (xn :: s) ..)
  (at level 0, format
  "'[hv' [ ::: '['  x1 , '/'  x2 , '/'  .. , '/'  xn ']' '/ '  &  s ] ']'"
  ) : seq_scope.

Notation "[ ::: x1 ; x2 ; .. ; xn ]" := (x1 :: x2 :: .. [:: xn] ..)
  (at level 0, format "[ ::: '['  x1 ; '/'  x2 ; '/'  .. ; '/'  xn ']' ]"
  ) : seq_scope.
*)

Definition ne_ind : forall (P : NonEmpty -> Type),
  (forall a, P [::: a])
    -> (forall a (l : NonEmpty), P l -> P [::: a & l])
    -> forall l : NonEmpty, P l.
Proof.
  move=> P H1 H2.
  case. elim=> [//|x xs IHx] H.
  case: xs => [|y ys] in IHx H *.
    have irr: ltn0Sn 0 = H by exact: proof_irrelevance.
    rewrite -irr.
    exact: H1.
  have irr: ltn0Sn (size (y :: ys)) = H by exact: proof_irrelevance.
  rewrite -irr.
  eapply (H2 x (@NE (y :: ys) _)).
  apply IHx.

  Grab Existential Variables.
  by [].
Defined.

Definition NE_length : NonEmpty -> nat := size.

Arguments NE_length ne /.

Lemma NE_length_spec : forall ne : NonEmpty, NE_length ne > 0.
Proof. by case. Qed.

Definition NE_inv (ne : NonEmpty) : a * seq a.
Proof.
  destruct ne.
  destruct s. discriminate.
  apply (a0, s).
Defined.

Arguments NE_inv ne /.

Definition NE_head (ne : NonEmpty) : a :=
  let: (x, xs) := NE_inv ne in x.

Arguments NE_head ne /.

Definition NE_last (ne : NonEmpty) : a :=
  let: (x, xs) := NE_inv ne in last x xs.

Arguments NE_last ne /.

Lemma size_combine : forall (xs ys : seq a),
  size xs > 0 -> size ys > 0 -> size (xs ++ ys) > 0.
Proof. case=> //. Defined.

Definition NE_append (l1 l2 : NonEmpty) : NonEmpty :=
  let: (NE s1 H1) := l1 in
  let: (NE s2 H2) := l2 in @NE (s1 ++ s2) (size_combine H1 H2).

Lemma ne_append : forall (xs ys : NonEmpty),
  forall (Hx : size xs > 0) (Hy : size ys > 0),
    NE_append xs ys = @NE (xs ++ ys) (size_combine Hx Hy).
Proof.
  case=> s1 H1.
  case=> s2 H2.
  move=> Hx Hy.
  have ->: H1 = Hx by exact: proof_irrelevance.
  have ->: H2 = Hy by exact: proof_irrelevance.
  by [].
Qed.

Lemma NE_head_append_spec : forall {xs ys : NonEmpty},
  NE_head (NE_append xs ys) = NE_head xs.
Proof. elim/ne_ind=> [x|x xs IHxs] ys; by case ys. Qed.

Lemma size_rcons_impl : forall z (s : seq a),
  0 < size s -> 0 < size (rcons s z).
Proof.
  move=> z.
  elim/last_ind=> //= [s x IHs] H.
  rewrite size_rcons.
  exact: ltnW.
Qed.

Definition ne_rcons (s : NonEmpty) z :=
  let: NE s H := s in @NE (rcons s z) (size_rcons_impl _ H).

Arguments ne_rcons s z /.

Lemma cat_ne_rcons x (s1 s2 : NonEmpty) :
  NE_append (ne_rcons s1 x) s2 = NE_append s1 [::: x & s2].
Proof.
  elim/ne_ind: s1 => /= [y|y ys IHys].
    case: s2.
Admitted.

Lemma ne_rcons_impl
  : forall (P : NonEmpty -> Type) x y (ys : seq a) H H',
  P (@NE [:: y] (ltn0Sn _))
    -> P (@NE (y :: rcons ys x) H) = P (@NE (rcons ys x) H').
Admitted.

Definition ne_rcons_cons (P : NonEmpty -> Type) x y (ys : seq a)
  : forall H H',
  P (@NE (rcons (rcons ys y) x) H) = P (ne_rcons (@NE (rcons ys y) H') x).
Proof.
  move=> H H'.
  elim/last_ind: ys => // [|z zs IHzs] in H H' *.
    by have <-: ltn0Sn 1 = H by exact: proof_irrelevance.
Admitted.

Lemma ne_last_ind : forall P,
  (forall x, P [::: x])
    -> (forall (s : NonEmpty) x, P s -> P (ne_rcons s x))
    -> forall s : NonEmpty, P s.
Proof.
  move=> P Hnil Hlast.
  case. elim/last_ind=> [//|xs x IHx] H.
  elim/last_ind: xs => [|ys y _] in IHx H *.
    have irr: ltn0Sn 0 = H by exact: proof_irrelevance.
    rewrite -irr.
    exact: Hnil.
  have H1: 0 < (size (rcons ys y)).+1.
    admit.
  have irr: ltn0Sn (size (rcons ys y)) = H1 by exact: proof_irrelevance.
  rewrite ne_rcons_cons.
    by rewrite size_rcons.
  move=> H'.
  eapply (Hlast (@NE (rcons ys y) _) x).
  apply IHx.
Defined.

Lemma NE_last_append_spec : forall {xs ys : NonEmpty},
  NE_last (NE_append xs ys) = NE_last ys.
Admitted.

Definition NE_reverse : NonEmpty -> NonEmpty.
Proof.
  case=> s H.
  have: 0 < size (rev s) by rewrite size_rev.
  exact: (@NE (rev s)).
Defined.

Lemma NE_append_assoc : forall (x y z : NonEmpty),
  NE_append x (NE_append y z) = NE_append (NE_append x y) z.
Proof.
  move=> [xs Hx] [ys Hy] [zs Hz].
  rewrite !ne_append /=.
    admit.
    admit.
  move=> H1 H2 /=.
Admitted.

Section Sorted.

Variable R : a -> a -> bool.
Context `{H : Transitive a R}.

Definition NE_Forall (P : a -> bool) : NonEmpty -> bool := all P.

Arguments NE_Forall P _ /.

Definition NE_all_true  (f : a -> bool) := NE_Forall f.
Definition NE_all_false (f : a -> bool) := NE_Forall (predC f).

Lemma NE_Forall_head : forall P (xs : NonEmpty),
  NE_Forall P xs -> P (NE_head xs).
Admitted.

Lemma NE_Forall_last : forall P (xs : NonEmpty),
  NE_Forall P xs -> P (NE_last xs).
Admitted.

Lemma NE_Forall_append : forall (P : a -> bool) xs ys,
   NE_Forall P xs /\ NE_Forall P ys <-> NE_Forall P (NE_append xs ys).
Admitted.

Section Membership.

(* Definition NE_member z (ne : NonEmpty) : bool := z \in list_of_ne ne. *)

(* Lemma NE_Forall_member_spec (z : A) (ne : NonEmpty A) : *)
(*   forall f, NE_Forall f ne -> NE_member z ne -> f z. *)
(* Admitted. *)

End Membership.

Inductive NE_StronglySorted : NonEmpty -> Prop :=
  | NE_SSorted_sing a   : NE_StronglySorted [::: a]
  | NE_SSorted_cons a l : NE_StronglySorted l -> NE_Forall (R a) l
                            -> NE_StronglySorted [::: a & l].

Lemma NE_StronglySorted_inv : forall x (l : NonEmpty),
  NE_StronglySorted (NE_append [::: x] l)
    -> NE_StronglySorted l /\ NE_Forall (R x) l.
Admitted.

Lemma NE_StronglySorted_inv_app : forall (l1 l2 : NonEmpty),
  NE_StronglySorted (NE_append l1 l2)
    -> NE_StronglySorted l1 /\ NE_StronglySorted l2.
Admitted.

Lemma NE_StronglySorted_impl_app : forall (l1 l2 : NonEmpty),
  NE_StronglySorted (NE_append l1 l2)
    -> R (NE_last l1) (NE_head l2).
Admitted.

End Sorted.

End NonEmptySub.

Definition NE_map {a b : Type} (f : a -> b) : NonEmpty a -> NonEmpty b.
Proof.
  case=> s H.
  set s' := map f s.
  have: 0 < size s' by rewrite size_map.
  exact: (@NE b s').
Defined.

Definition NE_fold_left {a b : Type} := @foldl.

Arguments NE [a] s H.

Arguments NE_all_true  [a] f _.
Arguments NE_all_false [a] f _.
