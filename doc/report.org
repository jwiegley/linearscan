#+TITLE: Experience Report: Building a register allocator in Coq

* Abstract

This experience report describes the development of a register allocation
algorithm in Coq and its subsequent inclusion in a larger Haskell project. It
documents the use of Coq from an engineering point of view (i.e., not solely
for proof work), and by a team initially unfamiliar with using Coq for
programming tasks. It presents multiple approaches to software design within a
dependently typed language, the hurdles encountered and how they were
overcome, and pitfalls others should consider when contemplating Coq for such
a task. Its conclusion is that Coq is an excellent functional language, for
which up-front knowledge of certain techniques is essential to reducing costs.
It is hoped the reader may save some of the time spent learning these
techniques, and thus facilitate the introduction of automated theorem proving
into production environments.

* Setting the stage

** Needed a new register allocator due to subtle bugs in the previous one
** Chose Coq to provide verification and fidelity of results
** No prior experience using Coq to build production software
** Deployment was chosen to be extraction to Haskell as a library

* Initial effort: Complex types

** Primary types were records of both data and propositions
** The resulting dependent types imposed many proof obligations

* Next effort: External proofs

** Propositions were moved from types into theorems
** Proving required complex induction over large functions
** Every change required proofs to be updated

* Next effort: Data types + Propositional types

** Propositions were moved to constructors of an inductive data type
** This divided between data and constructive predicates on the data
** Several fruits of this effort were kept, but imposed work

* Next effort: Proof by reflection

** Many propositions were exchanged for functions returning bool
** Switched to the ssreflect library, which supports this type of reasoning
** Allowed many proofs to avoid induction and use mainly rewriting

* Finalization of library code

** Abstracted library code lent itself well to reflection and proof
** Subsystems once "completed" needed little attention thereafter
** This where Coq shined, eliminating tests and creating confidence

* Continued work on application code

** Higher level code on top of libraries needed frequent change
** As the design evolved, many functions needed to be rewritten
** Owing to inductive predicates, proof obligations required constant work
** As the code evolved, changes became more and more difficult to make
** The last 20% of the work took an inordinate amount of time as a result

* Pressure release: Error results to avoid proof obligation

** To recover the pace of development, functions were permitted to "error out"
** Reporting error, instead of proving correctness, brought back flexibility
** When errors became common, it justified the proof work to eliminate them

* Pressure release: Coq as a functional language

** Most new functions abandoned proof restrictions and dependent types
** In this sense, Coq was just being used as if it were a "stricter Haskell"
** Core libraries carried high assurance, but the new code now requried testing

* The Haskell bridge

** Not all constructions could be made efficient on both sides
** Proof requirements do not prefer complex implementations!
** Monads were introduced to allow effect-producing callbacks
** Much work was done to optimize extraction, but led to difficult bugs

* Overall experience

** Coq would have been ideal for core library development
** Imposed a high engineering cost for application development
** Since not everything was proved, testing was still necessary
** Mounting time restrictions led to fewer and fewer proofs
** The final product required testing as with any application
** However, confidence levels at seeing all test pass was high

* Take-aways

** Coq is a powerful functional platform for crafting code of value
** It is not the right tool for large, complex applications
** Not unless one abandons most of what makes it so powerful
** A combination of Haskell and Coq would be of great value
** Getting this combination to work well requires some investment
